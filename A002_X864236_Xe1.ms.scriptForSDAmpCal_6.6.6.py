#!/usr/bin/env python
# ALMA Data Reduction Script
 
# Based on a script generated by the 'script generator'
# import analysisUtils as aU
# es = aU.stuffForScienceDataReduction()
# es.generateReducScript(msNames='foo.ms', step='SDampcal')

# Note the script is modified for pre-Cycle 3 data.
# - separate bdfflag application
# - non-linearity correction
# Modified by Kanako Sugimoto (National Astronomical Observatory of Japan)

# Calibration

thesteps = []
step_title = {0: 'Import of the ASDM',
              1: 'listobs',
              2: 'A priori flagging',
              3: 'Generation of the Tsys cal table',
              4: 'Generation of the Sky cal table',
              5: 'Do initial flagging',
              6: 'Calibration of the data into Kelvins',
              7: 'Split calibrated data',
              8: 'Application of non-linearity correction factor',
              9: 'Imaging',
              10: 'Determination of the Jy/K factors',
              11: 'Writing out the Jy/K factors'}

if 'applyonly' not in globals(): applyonly = False
try:
  print('List of steps to be executed ...', mysteps)
  thesteps = mysteps
except:
  print('global variable mysteps not set.')
if (thesteps==[]):
  thesteps = range(0,len(step_title))
  print('Executing all steps: ', thesteps)

# The Python variable 'mysteps' will control which steps
# are executed when you start the script using
#   execfile('scriptForCalibration.py')
# e.g. setting
#   mysteps = [2,3,4]# before starting the script will make the script execute
# only steps 2, 3, and 4
# Setting mysteps = [] will make it execute all steps.

import os
import re
import math

def createCasaTool(mytool):
    
    if (type(casac.Quantity) != type):  # casa 4.x
        myt = mytool()
    else:  # casa 3.x
        myt = mytool.create()
    return(myt)

def getDataColumnName(inputms):
    
    mytb = createCasaTool(tbtool)
    mytb.open(inputms)
    colnames = mytb.colnames()
    if 'FLOAT_DATA' in colnames:
        data_query= 'FLOAT_DATA'
    else:
        data_query = 'DATA'
    mytb.close()
    return(data_query)

def scaleAutocorr(vis, scale=1., antenna='', spw='', field='', scan=''):
    

    if os.path.exists(vis) == False:
        print("Could not find MS.")
        return
    if os.path.exists(vis+'/table.dat') == False:
        print("No table.dat.  This does not appear to be an MS.")
        return

    mymsmd = createCasaTool(msmdtool)
    mytb = createCasaTool(tbtool)

    conditions = ["ANTENNA1==ANTENNA2"]

    mymsmd.open(vis)

    if antenna != '':
        if not isinstance(antenna, (list, tuple)):
            antenna = [antenna]
        antennaids = []
        for i in antenna:
            if re.match("^[0-9]+$", str(i)): # digits only: antenna ID
                antennaids.append(int(i))
            else: # otherwise: antenna name
                antennaids.append(mymsmd.antennaids(i)[0])
        conditions.append("ANTENNA1 in %s" % str(antennaids))
    if spw != '':
        if not isinstance(spw, (list, tuple)):
            spw = [spw]
        datadescids = []
        for i in spw:
            datadescids.append(mymsmd.datadescids(spw=int(i))[0])
        conditions.append("DATA_DESC_ID in %s" % str(datadescids))
    if field != '':
        if not isinstance(field, (list, tuple)):
            field = [field]
        fieldids = []
        for i in field:
            if re.match("^[0-9]+$", str(i)): # digits only: field ID
                fieldids.append(int(i))
            else: # otherwise: field name
                fieldids.append(mymsmd.fieldsforname(i)[0])
        conditions.append("FIELD_ID in %s" % str(fieldids))
    if scan != '':
        if not isinstance(scan, (list, tuple)):
            scan = [scan]
        scannumbers = [int(i) for i in scan]
        conditions.append("SCAN_NUMBER in %s" % str(scannumbers))

    mymsmd.close()

    datacolumn = getDataColumnName(vis)

    print("Multiplying %s to the dataset %s column %s." % \
        (str(scale), vis, datacolumn))
    print("The selection criteria are '%s'." % (" && ".join(conditions)))

    mytb.open(vis, nomodify=False)
    subtb = mytb.query(" && ".join(conditions))
    try:
        data = subtb.getcol(datacolumn)
        print("Dimension of the selected data: %s" % str(data.shape))
        subtb.putcol(datacolumn, data*scale)
    except:
        print("An error occurred upon reading/writing the data.")
    finally:
        print("Closing the table.")
        mytb.flush()
        subtb.close()
        mytb.close()

if applyonly != True: es = aU.stuffForScienceDataReduction()

if re.search('^6.1.0', casalith.version_string()) == None:
  sys.exit('ERROR: PLEASE USE THE SAME VERSION OF CASA THAT YOU USED FOR GENERATING THE SCRIPT: 6.1.0')


# CALIBRATE_AMPLI: 
# CALIBRATE_ATMOSPHERE: 3c279
# CALIBRATE_BANDPASS: 
# CALIBRATE_DIFFGAIN: 
# CALIBRATE_FLUX: 
# CALIBRATE_FOCUS: 
# CALIBRATE_PHASE: 
# CALIBRATE_POINTING: 3c279
# OBSERVE_CHECK: 
# OBSERVE_TARGET: 3c279


# Import of the ASDM
mystep = 0
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  if os.path.exists('uid___A002_X864236_Xe1.ms') == False:
    importasdm('uid___A002_X864236_Xe1', asis='Antenna Station Receiver Source CalAtmosphere CalWVR CorrelatorMode SBSummary', bdfflags=True, lazy=False, process_caldevice=False, with_pointing_correction=True)
    os.system(os.environ['CASAPATH'].split()[0] + '/bin/bdflags2MS -f "COR DELA INT MIS SIG SYN TFB WVR ZER" uid___A002_X864236_Xe1 uid___A002_X864236_Xe1.ms')
  if applyonly != True: es.fixForCSV2555('uid___A002_X864236_Xe1.ms')

# listobs
mystep = 1
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  os.system('rm -rf uid___A002_X864236_Xe1.ms.listobs')
  listobs(vis = 'uid___A002_X864236_Xe1.ms',
    listfile = 'uid___A002_X864236_Xe1.ms.listobs')
  
  if applyonly != True:
    aU.getTPSampling(vis = 'uid___A002_X864236_Xe1.ms', showplot = True, plotfile = 'uid___A002_X864236_Xe1.ms.sampling.png')
    for i in ['PM03', 'PM04']:
      aU.getTPSampling(vis = 'uid___A002_X864236_Xe1.ms', antenna = i, showplot = True, plotfile = 'uid___A002_X864236_Xe1.ms.sampling.'+i+'.png')

# A priori flagging
mystep = 2
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  
  flagcmd(vis = 'uid___A002_X864236_Xe1.ms',
    inpmode = 'table',
    useapplied = True,
    action = 'plot',
    plotfile = 'uid___A002_X864236_Xe1.ms.flagcmd.png')
  
  flagcmd(vis = 'uid___A002_X864236_Xe1.ms',
    inpmode = 'table',
    useapplied = True,
    action = 'apply')
  

# Generation of the Tsys cal table
mystep = 3
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  os.system('rm -Rf uid___A002_X864236_Xe1.ms.tsys')
  
  gencal(vis = 'uid___A002_X864236_Xe1.ms',
    caltable = 'uid___A002_X864236_Xe1.ms.tsys',
    caltype = 'tsys')
  
  plotbandpass(caltable='uid___A002_X864236_Xe1.ms.tsys', overlay='time', 
    xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=False,
    showatm=True,pwv='auto',chanrange='92.1875%',showfdm=True, 
    field='', figfile='uid___A002_X864236_Xe1.ms.tsys.plots.overlayTime/uid___A002_X864236_Xe1.ms.tsys') 
  
  if applyonly != True: es.checkCalTable('uid___A002_X864236_Xe1.ms.tsys', msName='uid___A002_X864236_Xe1.ms', interactive=False)
  

# Generation of the Sky cal table
mystep = 4
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  os.system('rm -Rf uid___A002_X864236_Xe1.ms.sky')
  
  sdcal(infile = 'uid___A002_X864236_Xe1.ms',
    outfile = 'uid___A002_X864236_Xe1.ms.sky',
    calmode = 'otfraster')
  
  plotbandpass(caltable='uid___A002_X864236_Xe1.ms.sky', overlay='time', 
    xaxis='freq', yaxis='amp', subplot=22, buildpdf=False, interactive=False,
    showatm=True,pwv='auto',chanrange='92.1875%',showfdm=True, 
    field='', figfile='uid___A002_X864236_Xe1.ms.sky.plots.overlayTime/uid___A002_X864236_Xe1.ms.sky') 
  
  if applyonly != True: es.checkCalTable('uid___A002_X864236_Xe1.ms.sky', msName='uid___A002_X864236_Xe1.ms', interactive=False)
  

# Do initial flagging
mystep = 5
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  flagdata(vis = 'uid___A002_X864236_Xe1.ms',
    mode = 'manual',
    spw = '17:0~119;3960~4079,19:0~119;3960~4079,21:0~119;3960~4079,23:0~119;3960~4079')
  
  

# Calibration of the data into Kelvins
mystep = 6
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  from casarecipes.almahelpers import tsysspwmap
  tsysmap = tsysspwmap(vis = 'uid___A002_X864236_Xe1.ms', tsystable = 'uid___A002_X864236_Xe1.ms.tsys', trim = False)
  
  for i in ['0']:
    applycal(vis = 'uid___A002_X864236_Xe1.ms',
      applymode = 'calflagstrict',
      spw = '17,19,21,23',
      field = i,
      gaintable = ['uid___A002_X864236_Xe1.ms.tsys', 'uid___A002_X864236_Xe1.ms.sky'],
      gainfield = ['nearest', i],
      spwmap = tsysmap)
  
  if applyonly != True: es.SDcheckSpectra('uid___A002_X864236_Xe1.ms', msName='uid___A002_X864236_Xe1.ms', spwIds='17,19,21,23', interactive=False)
  
  

# Split calibrated data
mystep = 7
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  os.system('rm -Rf uid___A002_X864236_Xe1.ms.cal')
  
  split(vis='uid___A002_X864236_Xe1.ms', outputvis='uid___A002_X864236_Xe1.ms.cal', datacolumn='corrected')
  
  

# Application of non-linearity correction factor
mystep = 8
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  # Application of the caltable created by gencal with
  # caltype 'amp' appears to multiply x^-2 where x is
  # the factor in the caltable. So, desired multiplication
  # factor must be converted to its inverse square root
  # before creating caltable.
  to_amp_factor = lambda x: 1. / math.sqrt(x)

  os.system('rm -Rf uid___A002_X864236_Xe1.ms.nlc')

  gencal(vis='uid___A002_X864236_Xe1.ms.cal', caltable='uid___A002_X864236_Xe1.ms.nlc', caltype='amp', spw='', parameter=[to_amp_factor(1.25)])

  applycal(vis='uid___A002_X864236_Xe1.ms.cal', gaintable='uid___A002_X864236_Xe1.ms.nlc')



# Imaging
mystep = 9
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  # the values below were calculated assuming fwhmfactor = 1.13
  
  maxsize = 438.0
  
  theorybeam = {}
  theorybeam['17'] = 57.6765258076 # mean freq = 100.95
  theorybeam['19'] = 56.6577801937 # mean freq = 102.76515
  theorybeam['21'] = 51.6141510558 # mean freq = 112.80715
  theorybeam['23'] = 50.7702836079 # mean freq = 114.68215
  
  for spw in ['17', '19', '21', '23']:
  
    cell = theorybeam[spw]/9.0
    imsize = int(round(maxsize/cell)*2)
  
    for ant in ['PM03', 'PM04']:
  
      sdimaging(infiles = 'uid___A002_X864236_Xe1.ms.cal',
        field = '3c279',
        spw = spw,
        antenna = ant,
        nchan = 1,
        mode = 'channel',
        width = '4080',
        gridfunction = 'SF',
        convsupport = 6,
        phasecenter = 0,
        imsize = imsize,
        cell = str(cell)+'arcsec',
        overwrite = True,
        outfile = 'uid___A002_X864236_Xe1.ms.cal.%s.spw%s.image' % (ant, spw))
  

# Determination of the Jy/K factors
mystep = 10
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  srcflux = {}
  srcflux['17'] = 13.2214435465 # mean freq = 100.95
  srcflux['19'] = 13.0838667466 # mean freq = 102.76515
  srcflux['21'] = 12.387105634 # mean freq = 112.80715
  srcflux['23'] = 12.2678289253 # mean freq = 114.68215
  
  jyperk = {}
  
  for ant in ['PM03', 'PM04']:
  
    jyperk[ant] = {}
  
    for spw in ['17', '19', '21', '23']:
  
      if os.path.exists('uid___A002_X864236_Xe1.ms.cal.%s.spw%s.image' % (ant, spw)):
  
        peak = imstat('uid___A002_X864236_Xe1.ms.cal.%s.spw%s.image' % (ant, spw))['max'][0]
  
        jyperk[ant][spw] = srcflux[spw] / peak

# Writing out the Jy/K factors
mystep = 11
if(mystep in thesteps):
  casalog.post('Step '+str(mystep)+' '+step_title[mystep],'INFO')
  print('Step ', mystep, step_title[mystep])

  asdm = 'uid___A002_X864236_Xe1'
  date = '2014-07-07T22:43:40'
  ampcal = '3c279'
  band = '3'
  bb = {'19': '2', '21': '3', '17': '1', '23': '4'} # spw baseband number
  freq = {'19': '1.0276515e+11', '21': '1.1280715e+11', '17': '1.0095e+11', '23': '1.1468215e+11'} # spw mean frequency
  bw = {'19': '1992187500.0', '21': '1992187500.0', '17': '1992187500.0', '23': '1992187500.0'} # spw bandwidth
  elev = '71.794824799' # mean elevation
  temp = '-6.38316903666' # mean temperature
  
  f = open('uid___A002_X864236_Xe1.ms.cal.jyperk.txt', 'w')
  
  for ant in ['PM03', 'PM04']:
    for spw in ['17', '19', '21', '23']:
  
      if ant in jyperk.keys():
        if spw in jyperk[ant].keys():
          print('	'.join([asdm, ant, spw, str(jyperk[ant][spw]), date, ampcal, band, bb[spw], freq[spw], bw[spw], elev, temp]), file=f)
  
  f.close()
  


